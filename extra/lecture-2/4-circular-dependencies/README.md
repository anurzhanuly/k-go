### Циклические зависимости.

Чаще всего программа на go состоит из множества пакетов (аналогично пространствам имён в PHP). Каждая директория - это отдельный пакет.

Если пакет `a` зависит от пакета `b`, а `b` - от `a` - это сигнализирует о не очень качественном коде, о неидеальной структуре программы. В любых языках программирования рекомендуется избегать таких тесных циклических связей (об этом можно почитать, загуглив "low coupling"\"низкая связность").

Однако go идёт дальше и вообще не даст скомпилировать программу, если обнаружит в ней циклические зависимости.
Если попытаемся запустить `1-this-does-not-compile/main.go`, то получим ошибку:

```
package 1-this-does-not-compile
	imports 1-this-does-not-compile/user
	imports 1-this-does-not-compile/advert
	imports 1-this-does-not-compile/user: import cycle not allowed
```
Из этого вывода видно, что пакет `user` подключает пакет `advert`, а `advert` подключает `user`, что и приводит к ошибке.

Иногда циклические зависимости включают в себя целую цепочку пакетов типа `a -> b -> c -> d -> a`. Разобраться в причине ошибки в таком случае сложнее, и если мы только начинаем программировать на go - это зачастую раздражает.

Как быть в таких случаях?

Есть 3 распространённых подхода:

1. Объединить пакеты, зависящие друг от друга, в один пакет (см. пример в `2-single-package`). Достоинство решения - в его простоте. Недостаток - риск того, что весь код вашего проекта окажется в одном пакете и его будет неудобно поддерживать.
2. Вынести то, от чего зависят оба пакета, в ещё один - третий - пакет (см. пример в `3-many-packages`). Решение, опять же, довольно простое. Недостаток его в том, что таким образом можно сложить буквально каждую структуру или функцию в отдельный пакет, даже если они логически связаны друг с другом. Проект опять же будет сложно поддерживать.
3. Избегать использования структур, заменив их на интерфейсы (см. привер в `4-interfaces`). Как мы выяснили ранее, интерфейсы позволяют уменьшить связность пакетов между собой. Внедрять везде интерфейсы обычно трудоёмко и избыточно, но иногда это всё-таки является подходящим решением.

Чаще всего самыми разумными подходами являются 2 и 1, хотя не стоит забывать и про 3.

В наших проектах часто можно найти пакет типа `entity` или `model` с общими структурами данных, объединёнными по принципу, описанному в подходе 1. А поведение и бизнес-логика описываются в отдельных пакетах. 

Достаточно немного попрактиковаться в написании кода, чтобы получить интуитивное понимание того, в каких случаях какой подход применять.
