### Обработка ошибок

Обработка ошибок в go сделана неудобно. Это признают и сами разработчики языка. В новых версиях они планируют улучшить обработку ошибок, а пока придётся привыкать к текущему состоянию.

В go нет исключений, которые могли бы прервать обработку программы (есть panic, но об этом пока не будем). 
Ошибки являются такими же обычными переменными, как и любые другие значения. 
Их приходится проверять и обрабатывать вручную, что получается довольно многословно.

Для сигнализации об ошибках используется особенность языка - возможность возвращать несколько значений из функции.
Принято делать так, что функция, которая может завершиться с ошибкой, должна возвращать её последним результатом:

```
// Сигнатура функции, которая возвращает либо строку, либо ошибку
func getFile() (string, error) {}

// Сигнатура функции, которая возвращает либо строку и число, либо ошибку
func getStringAndNumberOrError() (string, int, error) {}

// Сигнатура функции, которая возвращает ошибку (либо nil, если ошибки не было)
func deleteAdvert(id int) error {}
```

После вызова таких функций нужно сначала проверять, не получили ли мы ошибку:

```
file, err := getFile()
if err != nil {
  // обработка ошибки (аналогично catch в PHP)
} else {
  // делаем что-то с file
}
```

Если функция вернула ошибку, то другим возвращённым из неё результатам (в данном случае - `file`) доверять нельзя. Там могут оказаться любые невалидные данные (обычно nil).

#### Что делать, если произошла ошибка?

##### 1. Игнорировать

В основном делать так нельзя. Скорее всего ваша программа рано или поздно аварийно остановится, если ошибки игнорировать. Кроме того, так вы не сможете расследовать причины инцидентов.

Такой подход эквивалентент коду в PHP 

```
try { .. } 
catch (\Exception $e) { 
  // ничего не делаем 
}
```

Однако go очень дотошно относится к ошибкам, и иногда (изредка!) игнорирование ошибки можно обосновать. 
Многие операции, которые в PHP или других языках не бросают исключений, в go могут вернуть ошибку. Например, мы часто конвертируем данные в JSON:
```
data := map[string]string{"key": "value"}
dataJson, err := json.Marshal(data)
```

Строго говоря, `json.Marshal` может вернуть ошибку - например, если мы попытаемся превратить в json какой-то особый тип вроде `chan`. 
Однако чаще всего мы превращаем в json обычные структуры данных, в валидности которых точно уверены.
Думаю, что игнорировать ошибки в таких случаях допустимо:

```
data := map[string]string{"key": "value"}
dataJson, _ := json.Marshal(data)
```

Достоинства подхода:
* Мало кода
* Не нужно думать

Недостатки подхода:
* Ненадёжно
* Чаще всего не подходит для продакшена

См. пример в `1-no-error-handling`.

##### 2. Просто вернуть ошибку

Проще всего (помимо полного игнорирования ошибки) - просто вернуть ошибку из текущей функции. Таким образом мы переложим ответственность за обработку ошибки на вызывающий код. 
Например:

```
file, err := getFile()
if err != nil {
    return nil, err
}
```

Делая так, рано или поздно в цепочке возвратов мы дойдём до функции (например, до `main`), из которой уже нельзя вернуть ошибку, и в ней всё-таки придётся принимать решение по её обработке.

Такой подход эквивалентент коду в PHP без использования try/catch (или с одним try/catch в index.php на весь проект целиком). То есть все исключения просто будут всегда прокидываться выше.

Достоинства подхода:
* Довольно мало кода
* Не нужно много думать

Недостатки подхода:
* Такую программу тяжело отлаживать и разбирать причины проблем
* Вполне вероятно, что функция, которой придётся принимать решение по обработке ошибки, не сможет сделать с ней ничего вменяемого
  * Например, при некоторых видах ошибках можно повторять операции (retry) 
  * При некоторых других ошибках можно делать fallback на альтернативный способ работы (например, получить данные не из кэша, а из API)

См. пример в `2-simple-error-handling`.

##### 3. Осознанно обрабатывать ошибки в месте их возникновения

Наиболее правильный подход - максимально качественно обработать ошибку там, где она возникла.
Под этим я имею ввиду:

* Применить какую-то бизнес-логику по обработке ошибки, если это уместно
  * Например, если файл не удалось прочитать, то можно тут же создать пустой файл, если это разумно в текущей ситуации
* Залогировать ошибку, добавив в лог саму ошибку и дополнительную информацию для её расследования
* Вернуть новую ошибку с подходящим описанием, "завернув" (wrap) в неё исходную ошибку

Достоинства подхода:
* Программу будет легко отлаживать и находить причины проблем

Недостатки подхода:
* Требует внимательности и большего количества кода :(

См. пример в `3-advanced-error-handling`.

### Как создавать новые типы ошибок

По-умолчанию в go ошибки создаются функцией `errors.New`, которая принимает строку.

Однако иногда мы хотим добавить дополнительную информацию об ошибке, например код и тело ответа от стороннего сервиса.

Для этого можно создать произвольную структуру и реализовать у неё метод `Error() string`, например:

```
type ApiError struct {
  ResponseCode int
  ResponseBody string
}

func (err ApiError) Error() string {
  return fmt.Sprintf("ошибка при запросе с кодом %d: %s", err.ResponseCode, err.ResponseBody)
}
```

Живой пример можно посмотреть в `4-custom-error`.

Важно помнить, что из-за особенностей работы интерфейсов в go, кастомные ошибки нужно возвращать по ссылке (например, `return &CustomError{...}`). А тип возвращаемой функцией ошибки всегда должен оставаться `error`, даже если функция всегда возвращает ошибки конкретного типа.

### Как отличать ошибки друг от друга

В языках с исключениями очень легко отделить одно исключение от другого по его классу.
В go тоже можно так делать, но немного по-другому. Для этого есть функции `errors.As` и `errors.Is`.

* `errors.Is(err, targetError)` позволяет проверить, является ли ошибка `err` ошибкой заданного типа `targetError`. Это полезно, если нам нужно понять, какая именно ошибка произошла.

* `errors.As(err, &targetError)` делает то же самое, но кроме этого записывает в `targetError` ошибку этого типа, если случилась именно она. В качестве targetError нужно передать указатель на ошибку интересующего нас типа. Это полезно, если мы используем кастомные структуры в качестве ошибок, и нам нужно "добраться" до конкретного типа ошибки, чтобы обратиться к её свойствам или методам.

Примеры см. в `5-error-types`.

### Почитать

* https://go.dev/blog/go1.13-errors - как работать с ошибками в go
* https://github.com/pkg/errors - библиотека для упрощения работы с ошибками
* https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md - план по изменению обработки ошибок в новых версиях go

### Выводы

* Обработка ошибок в go сделана непохоже на другие языки. В go приходится писать больше кода и следить за тем, чтобы не проигнорировать ошибку по невнимательности.
  * Возможно, в новых версиях языка ситуация исправится
* Обычно лучше логировать ошибки в месте их возникновения, а не выше по цепочке вызова функций
* Желательно добавлять больше смысла к ошибкам, "заворачивая" их так `fmt.Errorf("ошибка при чтении файла: %w", err)` или так `errors.Wrap(err, "ошибка при чтении файла")`.
  * заворачивание ошибки в формате `%w` через `fmt.Errorf` - это возможность стандартной библиотеки. Мне такой способ кажется некрасивым (:
  * `errors.Wrap` - аналогичная функция из сторонней библиотеки https://github.com/pkg/errors
* Часто бывает, что простой строки недостаточно для описания ошибок. В таком случае можно создавать новые типы - структуры, реализуя в них метод `Error() string`.
  * Однако при возврате ошибок нужно всегда возвращать тип `error`, а не кастомный тип.
* Для определения типа ошибки используем функцию `errors.Is`
* Для приведения `error` к конкретному типу используем функцию `errors.As`
* Рекомендую использовать библиотеку `https://github.com/pkg/errors`. При создании ошибок через библиотеку к ней добавляется стектрейс (как это делают исключения в PHP). При логировании таких ошибок мы увидим больше полезной информации в логах.
