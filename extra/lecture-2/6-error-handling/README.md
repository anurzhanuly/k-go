### Обработка ошибок

Обработка ошибок в go сделана неудобно. Это признают и сами разработчики языка. В новых версиях они планируют улучшить обработку ошибок, а пока придётся привыкать к текущему состоянию.

В go нет исключений, которые могли бы прервать обработку программы (есть panic, но об этом пока не будем). 
Ошибки являются такими же обычными переменными, как и любые другие значения. 
Их приходится проверять и обрабатывать вручную, что получается довольно многословно.

Для сигнализации об ошибках используется особенность языка - возможность возвращать несколько значений из функции.
Принято делать так, что функция, которая может завершиться с ошибкой, должна возвращать её последним результатом:

```
// Сигнатура функции, которая возвращает либо строку, либо ошибку
func getFile() (string, error) {}
```

После вызова таких функций нужно сначала проверять, не получили ли мы ошибку:

```
file, err := getFile()
if err != nil {
  // обработка ошибки (аналогично catch в PHP)
} else {
  // делаем что-то с file
}
```

Если функция вернула ошибку, то другим возвращённым из неё результатам (в данном случае - `file`) доверять нельзя. Там могут оказаться любые невалидные данные (обычно nil).

#### Что делать, если произошла ошибка?

##### 1. Игнорировать

См. пример в `1-no-error-handling`.

В основном делать так нельзя. Скорее всего ваша программа рано или поздно аварийно остановится, если ошибки игнорировать. Кроме того, так вы не сможете расследовать причины инцидентов.

Такой подход эквивалентент коду в PHP 

```
try { .. } 
catch (\Exception $e) { 
  // ничего не делаем 
}
```

Однако иногда всё-таки можно облегчать себе жизнь.
Например, мы часто конвертируем структуры в JSON:
```
data := map[string]string{"key": "value"}
dataJson, err := json.Marshal(data)
```

Строго говоря, `json.Marshal` может вернуть ошибку - например, если мы попытаемся превратить в json какой-то особый тип вроде `chan`. 
Однако чаще всего мы превращаем в json обычные структуры данных, в валидности которых точно уверены.
Думаю, что допустимо в таких случаях ошибки просто игнорировать:

```
data := map[string]string{"key": "value"}
dataJson, _ := json.Marshal(data)
```

Достоинства подхода:
* Мало кода
* Не нужно думать

Недостатки подхода:
* Ненадёжно
* Чаще всего не подходит для продакшена

##### 2. Ничего не делать, просто вернуть ошибку

См. пример в `2-simple-error-handling`.
Проще всего - ничего не делать и просто вернуть ошибку из текущей функции. Таким образом мы переложим ответственность за обработку ошибки на вызывающий код. 
Например:

```
file, err := getFile()
if err != nil {
    return nil, err
}
```

Делая так, рано или поздно в цепочке мы функции (например, `main`), из которой уже нельзя вернуть ошибку, и в ней всё-таки придётся принимать решение.

Такой подход эквивалентент коду в PHP вообще без использования try/catch (или с одним catch в index.php), т.е. все исключения просто прокидываются выше.

Достоинства подхода:
* Довольно мало кода
* Не нужно много думать

Недостатки подхода:
* Такую программу тяжело отлаживать и разбирать причины проблем
* Вполне вероятно, что функция, которой придётся принимать решение по обработке ошибки, не сможет сделать с ней ничего вменяемого
  * Например, при некоторых видах ошибках можно повторять операции (retry) 
  * При некоторых других ошибках можно делать fallback на альтернативный способ работы (например, получить данные не из кэша, а из API)  

##### 3. Качественно обрабатывать ошибки в месте их возникновения

Наиболее правильный подход - максимально качественно обработать ошибку там, где она возникла.
Под этим я имею ввиду:

* Применить какую-то бизнес-логику по обработке ошибки, если это уместно
  * Например, если файл не удалось прочитать, то можно тут же создать пустой файл, если это разумно
* Залогировать ошибку, добавив в лог больше информации
* Вернуть новую ошибку с подходящим описанием, "завернув" (wrap) в неё исходную ошибку

Достоинства подхода:
* Программу будет легко отлаживать и находить причины проблем

Недостатки подхода:
* Требует внимательности и большего количества кода :(

### Как создавать новые типы ошибок

TODO

### Как отличать ошибки друг от друга

В языках с исключениями очень легко отделить одно исключение от другого.
В go тоже можно так делать, но немного по-другому. Для этого есть функции `errors.As` и `errors.Is`.

TODO

### Почитать

* https://go.dev/blog/go1.13-errors - как работать с ошибками в go
* https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md - план по изменению обработки ошибок в новых версиях go
* https://github.com/pkg/errors - библиотека для упрощения работы с ошибками

### Выводы

* Обработка ошибок в go сделана непохоже на другие языки. В go приходится писать больше кода и следить за тем, чтобы не проигнорировать ошибку по невнимательности.
* Обычно лучше логировать ошибки в месте их возникновения, а не выше по цепочке вызова функций
* Желательно добавлять больше смысла к ошибкам, "заворачивая" их так `fmt.Errorf("ошибка при чтении файла: %w", err)` или так `errors.Wrap(err, "ошибка при чтении файла")`.
* Часто бывает, что простой строки недостаточно для описания ошибок. В таком случае можно создавать новые типы - структуры, реализуя в них метод `Error() string`.
  * Однако при возврате ошибок нужно всегда возвращать тип `error`, а не кастомный тип.
* Для определения типа ошибки используем функцию `errors.Is`
* Для приведения `error` к конкретному типу используем функцию `errors.As`
