### Конкурентность в HTTP сервере

О конкуретности и горутинах в go вам расскажут о дальнейших занятиях, а здесь пока затронем их опасные побочные эффекты. Пока что достаточно понимать, что горутины - это что-то вроде тредов\потоков в операционной системе; то есть код, который может выполняться одновременно.

Даже если вы ещё не используете горутины напрямую в своём коде и не изучали их - всё равно нужно иметь ввиду, что обрабатывая HTTP запросы ваш код выполняется в горутинах.

HTTP сервер в go запускает обработчик каждого запроса в отдельной горутине. Это даёт возможность обрабатывать несколько запросов одновременно (особенно на многоядерном компьютере). Однако это также значит, что запись в общие (глобальные) переменные может выполняться из множества горутин одновременно, а это чревато разного рода ошибками. Подробнее можно почитать про "гонки данных" в интернете, а здесь рассмотрим конкретные примеры.

В примере `1-counter` запускается простой сервер с двумя обработчиками:
- при обращении по адресу `/increment` увеличивается глобальная переменная - счётчик запросов
- при обращении по адресу `/metrics` выводится значение этого счётчика.

Если мы запустим и потестируем эту программу вручную, то покажется, что всё работает хорошо:
после каждого обновления `localhost:8080/increment` увеличивается значение, выводимое на `localhost:8080/metrics`.

Теперь попробуем сымитировать "высокую нагрузку" с помощью утилиты ab:

```
# очень быстро выполним 100000 запросов, пачками по 100 штук одновременно
# (используем утилиту apache benchmark)
ab -k -c 100 -n 100000 localhost:8080/increment
```

Ожидаем, что обращение к `localhost:8080/metrics` покажет число 100000, но на самом деле выведется число меньше (у меня, например, получилось 99830).

Почему?

Углубляться в объяснение не обязательно. Достаточно просто избегать изменения переменных, обращение к которым может выполняться из разных горутин.

Однако приведём и само объяснение:

Любое изменение данных в компьютере не атомарно. Даже простое увеличение обычного числа на самом деле состоит из 3 шагов:
1. Загрузка числа из ОЗУ в регистр процессора (инструкция ассемблера типа `mov variable-address, %eax`)
2. Увеличение этого значения на 1 (`add $1, %eax`)
3. Запись этого числа из регистра обратно в ОЗУ (`mov %eax, variable-address`)

Если две горутины (или два треда) одновременно загрузят в регистр число 0 и увеличат его, получив 1, то в памяти окажется число 1, а не 2. Одно изменение потеряется. 

С более сложными структурами данных всё обстоит ещё хуже: их изменение может включать в себя множество шагов, а значит - множество возможностей для ошибок. Приводить такие ошибки могут не просто к потере данных, но и к полной остановке программы.

Покажем это на примере `2-map`, где мы храним статистику посещений в хэш-таблице вида `дата-запроса => ip-адрес клиента`. Как и в прошлый раз, мы получим ожидаемый результат, если вручную повыполняем запросы `localhost:8080/request` (запись метрики) и `localhost:8080/metrics` (получение статистики).

Однако выполнив то же самое много раз и очень быстро: `ab -k -c 10 -n 1000 localhost:8080/request`, почти гарантированно получим остановку программы с ошибкой.
Объяснение, почему это происходит, оставляем в качестве упражнения слушателю.

### Выводы

* Даже если вы не запускаете горутины в своём коде, всё равно стоит знать об особенностях их работы
  * Кстати, даже функция `main` выполняется в горутине. См. [мой доклад на эту тему](https://www.youtube.com/watch?v=rloqQY9CT8I).
* Глобальные переменные лучше не использовать - особенно если вам нужно их изменять в процессе выполнения программы.
  * Не только потому, что их использование противоречит принципу "внедрения зависимостей"
  * Но и потому, что изменение глобальных переменных из горутин рано или поздно приведёт к ошибкам
* С локальными переменными внутри обработчика HTTP запроса можно делать что угодно. Локальные переменные у каждого обработчика свои, они не являются частью "разделяемой памяти".
  * Лучше не пытайтесь считерить и "скопировать" глобальную переменную в локальную для последующей модификации. (Домашнее задание: подумайте, почему?) 
* В дальнейших занятиях мы узнаем о других возможностях языка go - каналах, мьютексах, атомиках - которые позволяют безопасно обеспечивать доступ к общим данным из разных горутин... 
* ...однако это не значит, что нужно везде и всегда их использовать. Многие наши сервисы вообще не используют разделяемую память в своём коде, и это нормально. 
