### Пакет context

Пакет `context` может быть сложен для понимания новичков и заслуживает отдельной большой лекции.

Чтобы полноценно работать с пакетом `context`, сначала нужно разобраться с каналами, горутинами и `select`.
Пока мы этого не проходили, считайте изложенное ниже бонусным демонстрационным материалом.
Если выглядит сложно - можно его пропустить.

Пакет `context` - не самое красивое и удобное (на мой взгляд), но мощное решение разработчиков языка для сразу множества задач:

* Распространение событий в процессе работы программы и реагирование на них
* Отмена медленных операций
* Обмен дополнительными, "служебными" данными (`context.WithValue`) между функциями
  * Это может быть полезно, чтобы не "нагружать" функции множеством дополнительных аргументов, а "прятать" их в контекст 

Область применения контекста почти неограничена, но чаще всего он используется в таких сценариях:
* Обработка сигналов от операционной системы (например, нажатие ctrl+c или сигнал от kubernetes о том, что нужно остановить программу при деплое новой версии)
* Обработка таймаутов
  * Круто иметь возможность отменить операцию, которая может выполняться произвольно долго
  * Многие функции стандартной библиотеки умеют работать с контекстом, то есть могут быть отменены:
    * `exec.Command` - можно запустить произвольную shell-команду и отменить её
    * `http.Client` - можно отменять HTTP запросы, отправленные нашей программой в стороннюю систему
    * `sql` - можно отменять SQL запросы
* Обработка кастомных, запрограммированных нами событий
  * Пример из наших сервисов телефонии: событие "клиент положил трубку" обрабатывается как отмена контекста

### Примеры

В директории `1-slow-operation` пример программы, которая при запуске выполняет какое-то медленное действие, которое длится 5 секунд. В реальном проекте это может быть медленный запрос в стороннее API.

Если запустить эту программу и сразу нажать `ctrl+c`, то мы увидим сообщение "начинаем медленную операцию", но не увидим сообщения "медленная операция завершена". В реальном проекте это значило бы, что наша операция прервалась посередине, и информации об итоге её работы у нас нет (дошёл ли запрос до сервера?...).
В примере 3 мы увидим подход к решению такой ситуации, но сначала посмотрим на пример 2.

В директории `2-timeout` показан пример использования контекста с таймаутом.
У такого контекста "сработает" отмена после заданного промежутка времени (в нашем случае - 2 секунды).
Мы применим контекст к вызову shell-команды `sleep 5`. При запуске увидим, что команда завершилась с ошибкой через 2 секунды - как нам и требовалось!

Наконец, в директории `3-slow-operation-cancelable` - пример отмены произвольной медленной операции.
Он состоит из следующих основных шагов:
* создание отменяемого контекста `context.WithCancel`
* подписка на сообщения операционной системы, чтобы "отловить" нажатие на ctrl+c
  * мы отменим контекст, как только получим событие о нажатии ctrl+c
* запуск медленной операции
* ожидание одного из двух событий:
  * либо медленная операция успешно завершается
  * либо контекст отменяется. В этом случае у нас есть шанс отреагировать на это:
    * например, если мы обрабатывали задачу из очереди типа rabbitmq, можно вызвать `nack`, чтобы очередь повторила попытку обработки 
    * если мы обрабатывали строку в БД, можно сделать `update` и обновить статус строки
    * или хотя бы написать в лог

Несмотря на то, что такой код может выглядеть сложно, после изучения каналов и `select` воспринимать его будет проще. А ещё популярная библиотека `cobra` (аналог `symfony console`) упрощает обработку сигналов от операционной системы; примеры можно найти в её документации.

### Подробности

Можно почитать такие статьи:

* https://habr.com/ru/company/nixys/blog/461723/
* https://golang-blog.blogspot.com/2019/10/concurrency-context.html
* https://dev-gang.ru/article/rabota-s-kontekstom-v-go-tqvnsc2ysq/

### Выводы

* Контекст - важная и мощная (хоть и не совсем удобная) абстракция для распротранения событий в программе
* Помогает в программах, где происходит много *событий*
  * То есть штук, наступление которых сама программа не может контролировать 
  * В нашей компании встречается в сервисах телефонии 
* Можно использовать его для отмены операций и мягкой остановки/"graceful shutdown" программы
* Можно использовать для обработки событий, когда клиент не дождался ответа от вашего сервера и закрыл соединение
* Можно передавать в нём произвольные данные (использовать как шаблон "реестр"/"registry")
  * Лучше так не делать, если не уверены, что это действительно нужно
  * Этим пользуется, например, пакет `opentracing` для прокидывания информации о трассировке
* Это относительно "продвинутая" тема. Не переживайте, если пока что не поняли, как работать с контекстом.