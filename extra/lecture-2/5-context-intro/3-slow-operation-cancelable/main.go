package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"time"
)

func main() {
	// создаём контекст, который можно отменить
	ctx, cancel := context.WithCancel(context.Background())

	// создаём канал, в который будут отправляться сигналы от операционной системы к нашей программе
	osSignalChan := make(chan os.Signal, 1)

	// при нажатии ctrl+c (interrupt) в канал будет отправляться событие
	signal.Notify(osSignalChan, os.Interrupt)

	// в фоновой горутине будем ожидать поступления события в канал.
	// когда от ОС придёт событие interrupt, мы отменим контекст функцией cancel().
	go func() {
		<-osSignalChan
		fmt.Println("получен сигнал interrupt (ctrl+c), отменяем контекст")
		cancel()
	}()

	// вызовем медленную операцию с поддержкой отмены контекста
	slowOperationWithContext(ctx)
}

// Обёртка над медленной операцией, которую можно отменить через контекст
func slowOperationWithContext(ctx context.Context) {
	// в этот канал будем записывать сигнал о том, что медленная операция завершилась
	done := make(chan bool)

	// запускаем медленную операцию в фоновой горутине
	go func() {
		slowOperation()
		// после её завершения в канал запишется true
		done <- true
	}()

	// select похож на switch/case, но выполняет он не ветку с подходящим булевым условием,
	// а ту ветку, данные из которой получены первыми.
	select {
	case <-done:
		// медленная операция успешно завершилась, а контекст не был отменён.
		// делать ничего не нужно.
		break
	case <-ctx.Done():
		// контекст был отменён, а медленная операция не успела завершиться.
		// здесь у нас есть шанс выполнить компенсирующую операцию:
		// например, пометить задачу в БД как "отменённую".
		// или хотя бы просто написать в лог.
		fmt.Println("медленная операция прервана")
		break
	}
}

// Медленная операция
func slowOperation() {
	fmt.Println("начинаем медленную операцию")
	time.Sleep(time.Second * 5)
	fmt.Println("медленная операция завершена")
}
